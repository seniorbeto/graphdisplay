# -*- coding: utf-8 -*-
"""graph-dictionaryWD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LAeO6qpKKHWzq7uCwT952r-BlIBeztl6

# Graph implementation using a Python dictionary

This implementation allows to represent any kind of graphs.
"""
from .graphdisplay import GraphGUI

class AdjacentVertex:
    """This class allows us to represent a tuple with an adjacent vertex
    and the weight associated (by default 1, for non-unweighted graphs)"""

    def __init__(self, vertex, weight=None):
        self._vertex = vertex
        self._weight = weight

    def __str__(self):
        if self._weight != None:
            return '(' + str(self._vertex) + ',' + str(self._weight) + ')'
        else:
            return str(self._vertex)


class Graph():
    def __init__(self, vertices, directed=True):
        """We use a dictionary to represent the graph
        the dictionary's keys are the vertices
        The value associated for a given key will be the list of their neighbours.
        Initially, the list of neighbours is empty"""
        self._vertices = {}
        for v in vertices:
            self._vertices[v] = []
        self._directed = directed

    def addEdge(self, start, end, weight=None):
        if start not in self._vertices.keys():
            print(start, ' does not exist!')
            return
        if end not in self._vertices.keys():
            print(end, ' does not exist!')
            return

        # adds to the end of the list of neigbours for start
        self._vertices[start].append(AdjacentVertex(end, weight))

        if self._directed == False:
            # adds to the end of the list of neigbours for end
            self._vertices[end].append(AdjacentVertex(start, weight))

    def containsEdge(self, start, end):
        if start not in self._vertices.keys():
            print(start, ' does not exist!')
            return 0
        if end not in self._vertices.keys():
            print(end, ' does not exist!')
            return 0

        # we search the AdjacentVertex whose v is end
        for adj in self._vertices[start]:
            if adj._vertex == end:
                if adj._weight != None:
                    return adj._weight
                else:
                    return 1  # unweighted graphs
        return 0  # does not exist

    def removeEdge(self, start, end):
        if start not in self._vertices.keys():
            print(start, ' does not exist!')
            return
        if end not in self._vertices.keys():
            print(end, ' does not exist!')
            return

        # we must look for the adjacent AdjacentVertex (neighbour)  whose vertex is end, and then remove it
        for adj in self._vertices[start]:
            if adj._vertex == end:
                self._vertices[start].remove(adj)
        if self._directed == False:
            # we must also look for the AdjacentVertex (neighbour)  whose vertex is end, and then remove it
            for adj in self._vertices[end]:
                if adj._vertex == start:
                    self._vertices[end].remove(adj)

    def __str__(self):
        result = ''
        for v in self._vertices:
            result += '\n' + str(v) + ':'
            for adj in self._vertices[v]:
                result += str(adj) + "  "
        return result

